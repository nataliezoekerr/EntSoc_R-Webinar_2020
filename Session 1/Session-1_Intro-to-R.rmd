---
title: 'Session 1: Introduction to R'
author: "Brian Lovett & Natalie Z. Kerr"
date: "10/7/2020"
output: html_document
---

**Description:** This session will lay a coding foundation for R beginners. We will familiarize you with using the RStudio interface, RScripts and RMarkdown. Students will learn basic commands in the ever-changing R language, how to interpret errors and package installation. We will use these tools to wrangle and visualize data using Tidyverse packages.

## 1. Introduction to R Studio, R Scripts, RMarkdown/RNotebooks, and R Projects. 
#### a. What is R?
R is a programming language. Essentially, R is a medium for dialogue between you and your computer about your data. We shall highlight the lingual aspects of R throughout this introduction.

#### b. Why use R?
![xkcd comic: The General Problem](https://imgs.xkcd.com/comics/the_general_problem.png) 

R is:

* Free
* Repeatable
* Easy to share
* Won't alter your original data
* Saves time with reapplication
* Has community sourced packages
* Has a helpful online community

#### c. What does R do?
R is a way of telling your computer what you want done with your data. This language is geared toward mathematics, which is your computer's forte. You will need to think like a computer. We will see that this language is very specific about what it wants and what it will give you- pay attention to these details!

#### d. What does R **not** do?
**Learning R is not learning statistics!** R can implement any number of statistical tests and analyses, and regardless of if they're appropriate, it will run them on properly formatted data. Be careful to have a plan for what statistics you want to calculate **before** you start coding.

#### e. Why do I need RStudio?
Primarily, RStudio provides a graphical user interface for coding in R. R alone is a console: a blank line asking for immediate instructions. Certainly, you can quickly code something like this, but part of coding is writing scripts that are reproducible. RStudio allows you to view:

1. Source (scripts and data)
2. Environment (saved objects and functions)
3. The console (where commands are run)
4. Files, Packages and Help (to orient you)

RStudio makes it easier to navigate between code, the console and output, while also displaying the characteristics of your R environment. You can think of RStudio as an "R organizer".

![The anatomy of the RStudio screen.](Data/RStudio_Screen.png)

#### f. What are R scripts?
R scripts list commands you want to write, edit and save. In a simple example, a script may load data (command 1), calculate a statistic on that data (command 2), then plot that statistic (command 3). With this script in hand, you can instantly run the exact same analysis. You can also share the script and data and allow colleagues to replicate and contribute to analysis.

#### g. Why use RMarkdown or RNotebooks?
RMarkdown and and RNotebooks allow you to create sharable documents that combine a written narrative, code and results. RMarkdown syntax, which is used in RNotebooks, can be knit into pdfs or html files. (This was written via RMarkdown). RMarkdown and RNotebooks also allow you to run and view chunks of code within the document.

#### h. What are R Projects?
R Projects streamline your script development. A .Rproj file keeps track of what files you are viewing and will ensure you have a consistent working directory. R Projects open in their own R session, which allows you to jump right back into coding.

## 2. Taking action with functions (verbs)
#### a. What is a function?
Programming generally can be considered as a series of pipes: information goes in, the pipe does something (a function), then information comes out. Your aim is to ensure that appropriate (quality) information goes in, and that the "pipe" is doing the right thing. This pipe metaphor is appropriate too when you consider the idea of a "square peg in a round hole". Half of the battle is understanding what type of information each function needs.

Functions can be thought of as verbs because they act on whatever objects you provide and often need additional information. Verbs not only tell you what is happening, but they also tell you something about when it happened and how many people were involved. The additional information you supply to functions are called arguments. Some are optional and others have defaults.

#### b. The anatomy of a function.
Regardless of what they do, functions share certain characteristics:

* Function name (can be any word)
* ( - marks the start of arguments
* Arguments
  + Each argument has a name and can be set to something
  + Some arguments will have defaults
  + Some arguments will be optional
  + Without names, order of arguments matters
* ) - marks the end of arguments

A function can be generalized as: function(argument, argument, argument)
Let's explore some functions:
```{r functions, include=T}
#Note: Grey boxes contain code that is sent to the console, and white boxes below are the output.

#The function c (short for "combine") returns its contents as vector/list
#The arguments for c are the objects you want to combine
seuss=c(1, "fish", 2, "fish")
seuss

#A colon is the coding equivalent of "through" 1:3 returns 1, 2 and 3. 3:1 returns 3, 2 and 1.
nums=c(1:100)
nums

mean(x = nums)
mean(nums)
```
Since our object "seuss" contained numbers and words (words are "strings of characters" to your computer), this was formatted as a character class. A vector of 1-100 cooperates with the integer class, so the "nums" object is an integer class. This reliable behavior is built into the function c().

#### c. You can create your own functions!
You may want to write your own function to streamline your code or share specific workflows with others. If you find yourself copying and hard coding a few lines over and over, they may work better as a function.
To write your own function, you need to specify the arguments of the function, the name of the function and the commands within the function.

```{r bespoke functions, include=T}
#Here we will write a simple function that allows you to repeat "given numbers" (input: argument 1) x number of times" (n: argument 2) and take their sum. Within this custom function, we will use the functions rep.int(x, times) and sum(..., na.rm=F).

repsum=function(input, n=2){
  reps=rep.int(x=input, times=n)
  sum(reps)
}

#Note: the object "reps" was created within our function and so will not be added to your environment
#Also Note: we established a default for n if that argument is missing.

repsum(input=nums)

#Relying on order for argument assignment
repsum(nums, 3)

repsum(input=nums, n=4)
```

Functions can work the same when nested, but they can be hard to read when you're starting out.
```{r nested functions, include=T}
repsum2=function(input, n=2){
  sum(rep.int(x=input, times=n))
}

repsum2(nums)

repsum2(nums, n=4)

```
This nesting avoids creating the object "reps", but it will be harder for future you and others to read

#### d. Creating loops


#### e. R as a calculator
The R base language has intuitive math functions built in. These will follow order of operations.
```{r}
1+2
1+2*3
(1+2)*3
2^3
3/4
```

## 3. R as an object-oriented language (nouns)
Information is stored in R as objects, and R objects have a wide variety of classes. Some fundamental classes are:

* Number
```{r number, include=T}
as.numeric(5)
numeric(length=5)
```
* Character
```{r character, include=T}
as.character(5)
```
* Factor
```{r factor, include=T}
factor(5)
```
* Integer
```{r integer, include=T}
as.integer(5)
```
* Matrix
```{r matrix, include=T}
matrix(5)
```
* Data frame
```{r data frame, include=T}
data.frame(col=5)
```
* Logical
```{r logical, include=T}
is.na(5)
```

These examples are all ephemeral: R read our command and returned what we asked for, but objects are much more powerful when you store them. Typically you will store whatever objects you're working with. You can store them in two ways:
```{r storing objects, include=T}
five <- as.numeric(5)
six = factor(6)

#Running the name of an object will display that object
five
six
```

Since I deviously created these objects named "five" and "six" in different classes, let's compare them. First, we can check the class for ourselves:
```{r check class, include=T}
class(five)
class(six)

five+five
six+six
```

We can also look at specific characteristics of these objects:
```{r object characteristics, include=T}
length(five)
length(six)

levels(six)
```

Levels are a powerful aspect of factors, let's take a deeper look at this:
```{r fun with factors, include=T}
c(12:1)
c("apples", "oranges", "pears", "bananas")

nums=factor(c(12:1))
fruits=factor(c("apples", "oranges", "pears", "bananas"))

nums
levels(nums)
levels(fruits)

as.character(nums)
as.numeric(nums)

as.character(fruits)
as.numeric(fruits)
as.numeric(as.character(fruits))
```

You can also reorder levels without reordering the factor itself.
```{r reordering factors, include=T}
new.order=c(1, 4, 3, 2)
fruits

#To do this, we will use the brackets, which are an object element that allows you to specify order
levels(fruits)
levels(fruits)[new.order]
fruits=factor(fruits, levels=levels(fruits)[new.order])
fruits
```
The order of a factor can determine, for example, the order your data is displayed on a plot (as we shall see later).

## 4. Packages, the tidyverse and tidy data
#### a. What is a package?
Everything we've discussed so far is part of the base R language. These are functions that R knows out of the box. Packages extend that language for specific purposes: it's a vocabulary lesson or "extension pack" for R. Packages are a collection of functions for you to use, loosely organized by purpose or field. Some packages are designed for field-specific purposes and others are more general. Other scientists can upload their packages into repositories, which stores them and allows them to be easily downloaded. CRAN (The Comprehensive R Archive Network) is a major repository for R packages, but there are others, such as Bioconductor.

Packages will have manuals that explain each function in the package and each of its arguments. Packages will often also have tutorials or vignettes via vignette() that walk you through basic usage. These are a good jumping off point if you want to explore a new package. Packages and their documentation can be updated and maintained by scientists who write them.

To install a package, you can use the command install.packages(). You can install packages by supplying a character or vector of characters: "package" or c("package 1", "package 2").

Use this command:
>install.packages("readr")

Packages will be downloaded and stored as a binary that you can call with the command library(package). Even if you have installed a package, a new session of R will be unaware of it until you call it with library(). The argument for library is the name of the package, so it doesn't have to be in quotes (a character to your computer).

```{r load packages, include=T}
library(readr)
```

The functions in the package readr are now available to our computer. We can check this by opening a help window on readr or clicking on the Packages tab. To access help on any function or package, type into the council ?package or ?function. You can also use the searchbar in the RStudio Help tab.

We can try:
>?readr

#### b. What is the tidyverse?
The tidyverse is a collection of packages developed and maintained by data scientists at RStudio. These packages are ggplot2 (for data visualization), dplyr (for data manipulation), tidyr (to help tidy data), readr (to read data), purr (to streamline functions), tibble (for tidy data frames- tibble class), stringr (for wrangling character strings), forcats (for managing factors). Installing and loading "tidyverse" will install and load each of these packages. library("tidyverse") is the at the top of many R scripts.

Each of these packages has stellar documentation, and we will only touch on the wonderful things some of them can do. I highly recommend reading the documentation of tidyverse packages you think would be useful to you in full: https://www.tidyverse.org/packages/

#### c. What is tidy data?
The tidyverse is oriented around the concept of tidy data. This is data which is formatted such that each column represents a unique variable or measurement and each row represents a single experimental unit.

Let's break down an example. If you're conducting a simple experiment examining blood feeding preference for mosquitoes, you may design it so that you offer 20 female mosquitoes either of two sources of blood (horse or goose blood) and repeat this experiment in triplicate. You may measure how much time each female spends feeding.

To tidily format this data, you will give each individual mosquito her own row, and the columns will be: blood source (horse or goose), individual number (1-20), replicate (1-3) and time spent feeding (s). It may sound intuitive, but this basic principle for recording and thinking about your data allows for powerful, fast and (relatively) painless data processing.

This formatting will result in data that is easy for your computer to manage. #Show the data.

### 5. Working with data
Data analysis in R is streamlined by the various tidyverse packages. We will use some below.

R is certainly equipped to do any kind of data manipulation; however, particularly when you're starting out, don't be afraid to make a small change in some other program (like Excel) to speed up your analysis. As you learn R, even minor data manipulation will become easier in RStudio.

#### a. Loading data
There are a variety of ways to load data in R. The simplest is to code data in manually. A data frame specifies columns and its contents, so for the example above.
```{r data frames from scratch, include=T}
#Create each column
blood=rep(c("goose", "horse"), each=60)
individual=rep(c(1:20), times=6)
replicate=rep(c(1:3), each=20, times=2)
time=rnorm(n=120, mean=60, sd=30)

#Combine into a data frame
mosq.dat=data.frame(blood, individual, replicate, time)

dim(mosq.dat)

str(mosq.dat)

```
This would also work if our objects were nested within the data.frame() function. A tibble can be made the same way using the function tibble().

R also has data built in. You can peruse these datasets by running the function data(). These are immediately accessible to any R user simply by calling their names. Rather unfortunately, the only insect-oriented data is InsectSprays. This is described as "Effectiveness of Insect Sprays" and is described simply: "The counts of insects in agricultural experimental units treated with different insecticides." Despite this simplistic view of IPM, which dates back to a data analysis paper from 1942, we will use this simple data for manipulation below.

```{r load InsectSprays, include=T}
dat=InsectSprays
```

Typically, you will import in files you have generated yourself. Base R has the function read.csv() and readr provides read_csv(). The readr option will import data as a tibble and has more options that are intuitive. However, RStudio has an "Import Dataset" button, which gives you a user interface for either option. I recommend using this and checking the preview provided. Both will return in your console the command for importing that data.

We will import our own comma separated values file (csv) containing iNaturalist observations for Monarch butterflies from 2018-2020. This command was generated using the RStudio "Import Dataset" button, in which we specified the name iNat.dat (much easier to manage than "iNat_monarch2018_2020")

```{r load iNat data, include=T}
iNat.dat <- read.csv("Data/iNat_monarch2018_2020.csv")
```

#### b. Manipulating data
Now that we have our data loaded, we can manipulate it. Let's use some special characters to subsetting our InsectSpray data. $ will allow you to select specific columns. You can create new columns using this operator, as well.

```{r selecting columns, include=T}
dat

dat$count

#Here we are creating the column "n" with the value 30
dat$n=30
```

This operator can also calculate between columns (across a row). 

```{r calculate via columns, include=T}
dat$dead=dat$n-dat$count
```

Double brackets function similar to the $ operator, except you can include a number or a name. Single brackets allow you to pick specific cells by coordinates: [row, column]. If a comma is not included, the value is assigned to column.
```{r brackets, include=T}
dat[[1]]
dat[["count"]]

#This command will extract the second row
dat[2,]

#This command will extract the second column
dat[2]

#This command will extract the value from the first column and the second through fourth row
dat[2:4,1]
```

The subset() function can select rows from a data frame based on a logical expression (T/F statement). We can select rows where >6 died like this:
```{r subset function, include=T}
subset(x=dat, subset=dat$dead>6)
```
Another useful function for subsetting is grep(). This function searches for patterns and returns where in a sequence that pattern occurs. We can use grep to find each row that contains our pattern "2" in the column count (i.e., 20, 12 and 2 would be included because they contain 2). 

```{r grep, include=T}
#grep() returns the row numbers
grep("2", dat$count)

#We can combine this with [] to subset those rows from our entire data frame
#Note: we need to include a comma after grep() so that [] does not default to columns
dat[grep("2", dat$count),]
```
There are also dplyr options for subsetting that are very intuitive.
```{r dplyr subsetting, include=T}
#Since this is our first time using dplyr, we will call the tidyverse which loads dplyr
#install.packages('tidyverse')
library(tidyverse)

filter(dat, dat$count>6)
slice_head(dat, prop=.25)
select(dat, c(count, spray))
```
#### c. Transformation, grouping and calculations
Here we will further solidify the concept of pipes. Pipes in R look like this %>% and they originate from the package magrittr. RStudio recognizes pipes and will indent automatically when you return on a line ending in a pipe. Pipes send the output from one command into the next command. Pipes allow you to code complex things that are also readable: without pipes, you would need to create a number of intermediate objects or nest many functions to reach the same end.

In our first example, we will use pipes to group our observations by spray type, then take the mean number of insects remaining. We will use the following dplyr functions:

* select("list of columns")
* group_by("grouping list")
* summarize("column"="calculation")

```{r pipes, include=T}
#First we send our dat data frame into the pipe
dat.stat= dat %>%
#We've created new columns so we'll select our original two InsectSpray columns
  select(count, spray) %>%
#In the line below, we are grouping the data frame by 
  group_by(spray) %>%
#Once grouped, we will calculate the mean and stdev using the functions mean() and sd()
  summarize(mn=mean(count), sd=sd(count))
```
This quickly tells us the very simple story that, whatever these sprays were in 1942, far fewer insects survived in sprays C, D and E.

Our last example with this data set is pivoting. pivot_wide will transform your data to maximize columns (think "less tidy") and pivot_longer will do the opposite. Certainly you will work with data where one of these transformations is necessary. Call the vignette vignette("pivot").

```{r pivoting, include=T}
#First, we will add an individual column to our InsectSpray dataset
dat = dat %>%
  group_by(spray) %>%
  mutate(individual=c(1:12))

wide.dat= dat %>%
  select(count, spray, individual) %>%
  pivot_wider(names_from=individual, values_from=count)

wide.dat

#We can transform this back with the complementary function pivot_longer
long.dat = wide.dat %>%
#Below, we can use - to signal which columns should not be pivoted. This is shorthand for the argument "cols", which alternatively needs a list of columns to pivot.
  pivot_longer(-spray, names_to="individual", values_to="count")

long.dat
```

Before we move on, we will make some adjustments to our iNaturalist data. This process of tidying or transforming your data before visualization is called wrangling or munging.

#### d. Exporting tables


#### 6. Plotting in R

```{r, include=T}

```

#### 7. Mapping in R

```{r , include=T}

```
